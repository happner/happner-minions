#!/usr/bin/env node

var opts = JSON.parse(process.argv[2]);

var name = opts.config.name;
var marshal = opts.marshal;
var config = opts.config.config;
var script = opts.config.script;
var externalInterfaces = require('../lib//util').externalInterfaces;
var errorize = require('errorize');
var os = require('os');

var Config = require((opts.config.home || '..') + '/configs/mesh_' + config);
var Script = require((opts.config.home || '..') + '/scripts/mesh_' + script);

var Happner = require('happner');

var error = function(e) {

  if (report && report.exchange) {
    e = errorize(e); // grrrr  !!!!!!BAN ON THROWING STRINGS!!!!!!
    var ee = {
      name: e.name,
      message: e.message,
      stack: e.stack ? e.stack.split(os.EOL).slice(1,3).map(function(line) {
        return line.trim();
      }) : null
    }
    Object.keys(e).forEach(function(key) {
      ee[key] = e[key]
    });
    return report.exchange['happner-minions'].minionError(name, ee)
    .then(function() {
      process.exit(1);
    })
    .catch(function() {
      console.error(e);
      process.exit(1);
    });
  }
  process.exit(1);
}

// Reports back to marshal.
var report = new Happner.MeshClient({
  host: marshal.datalayer.address.address,
  port: marshal.datalayer.address.port,
});

report.login()
.then(function() {
  return Happner.create(Config.createConfig(opts))
})
.then(function(mesh) {
  var name = mesh._mesh.config.name;

  var address = mesh._mesh.datalayer.server.server.address();
  if (address.address == '0.0.0.0') {
    // assume first iface
    var ifaces = externalInterfaces();
    address.address = ifaces[0];
  }

  return report.exchange['happner-minions'].minionReady({
    name: name,
    address: address,
    timestamp: Date.now(),
    task: {
      title: Script.title,
      stepsRemaining: Script.steps,
      stepsDone: {}
    }
  })
  .then(function() {

    
    // return Script.run(name, report, mesh);

  })
})
.catch(error);
